// Generated by CoffeeScript 1.9.3
var CalculateAdjacentCells;

CalculateAdjacentCells = require(app_path + "/services/CalculateAdjacentCells");

describe('CalculateAdjacentCells', function() {
  describe('#constructor', function() {
    return it('attempts to find a valid location for each adjacent vertex', function() {
      var service;
      sinon.stub(CalculateAdjacentCells.prototype, 'validLocation', function() {});
      service = new CalculateAdjacentCells(null, [], 1, 1);
      (expect(service.cells.length)).to.equal(8);
      return CalculateAdjacentCells.prototype.validLocation.restore();
    });
  });
  describe('#get', function() {
    return it('gets the array of cells', function() {
      var cells, i, j, len, ref;
      sinon.stub(CalculateAdjacentCells.prototype, 'validLocation', function() {
        return 1;
      });
      cells = new CalculateAdjacentCells(null, [], 1, 1);
      (expect(cells.cells.length)).to.equal(8);
      ref = cells.cells;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        (expect(i)).to.equal(1);
      }
      return CalculateAdjacentCells.prototype.validLocation.restore();
    });
  });
  return describe('#validLocation', function() {
    var grid, gridMock, validLocation;
    grid = {
      at: (function() {}),
      set: (function() {}),
      validIndices: (function() {})
    };
    gridMock = null;
    validLocation = function(g, x, y) {
      return CalculateAdjacentCells.prototype.validLocation(g, x, y);
    };
    before(function() {
      return sinon.stub(CalculateAdjacentCells.prototype, 'checkAbove', function() {});
    });
    after(function() {
      return CalculateAdjacentCells.prototype.checkAbove.restore();
    });
    beforeEach((function(_this) {
      return function() {
        return gridMock = sinon.mock(grid);
      };
    })(this));
    afterEach((function(_this) {
      return function() {
        return gridMock.restore();
      };
    })(this));
    it('returns null if the vertices are invalid', (function(_this) {
      return function() {
        gridMock.expects('at').once().returns(false);
        (expect(validLocation(grid, 1, 1))).to.equal(null);
        return gridMock.verify();
      };
    })(this));
    return it('returns a tuple if the location is empty', (function(_this) {
      return function() {
        var result;
        (gridMock.expects('at')).once().returns(null);
        result = validLocation(grid, 1, 2);
        (expect(result.x)).to.equal(1);
        (expect(result.y)).to.equal(2);
        return gridMock.verify();
      };
    })(this));
  });
});
