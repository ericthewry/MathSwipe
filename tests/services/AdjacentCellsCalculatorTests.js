// Generated by CoffeeScript 1.9.3
var AdjacentCellsCalculator;

AdjacentCellsCalculator = require(app_path + "/services/AdjacentCellsCalculator");

describe('AdjacentCellsCalculator', function() {
  describe('#constructor', function() {
    before((function(_this) {
      return function() {
        return sinon.stub(AdjacentCellsCalculator.prototype, 'validLocation', function() {});
      };
    })(this));
    after((function(_this) {
      return function() {
        return AdjacentCellsCalculator.prototype.validLocation.restore();
      };
    })(this));
    return it('attempts to find a valid location for each adjacent vertex', function() {
      var cells, grid, service;
      grid = [[1, 2], [3, 4]];
      cells = [1, 2, 3, 4];
      service = new AdjacentCellsCalculator(grid, cells, 1, 2);
      (expect(service.grid)).to.equal(grid);
      (expect(service.cells)).to.equal(cells);
      (expect(service.x)).to.equal(1);
      return (expect(service.y)).to.equal(2);
    });
  });
  describe('#calculate', function() {
    before((function(_this) {
      return function() {
        return sinon.stub(AdjacentCellsCalculator.prototype, 'validLocation', function() {
          return 1;
        });
      };
    })(this));
    after((function(_this) {
      return function() {
        return AdjacentCellsCalculator.prototype.validLocation.restore();
      };
    })(this));
    return it('gets the array of cells', function() {
      var cells, i, j, len, ref, results;
      cells = new AdjacentCellsCalculator(null, [], 1, 1);
      cells.calculate();
      (expect(cells.cells.length)).to.equal(8);
      ref = cells.cells;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        results.push((expect(i)).to.equal(1));
      }
      return results;
    });
  });
  return describe('#validLocation', function() {
    var grid, gridMock;
    grid = {
      at: (function() {}),
      set: (function() {}),
      validIndices: (function() {})
    };
    gridMock = null;
    beforeEach((function(_this) {
      return function() {
        return gridMock = sinon.mock(grid);
      };
    })(this));
    afterEach((function(_this) {
      return function() {
        return gridMock.restore();
      };
    })(this));
    it('returns null if the vertices are invalid', (function(_this) {
      return function() {
        var result;
        gridMock.expects('validIndices').once().returns(false);
        result = AdjacentCellsCalculator.prototype.validLocation(grid, 1, 1);
        (expect(result)).to.equal(null);
        return gridMock.verify();
      };
    })(this));
    return describe('the vertices are valid', (function(_this) {
      return function() {
        var emptyStub;
        emptyStub = null;
        beforeEach(function() {
          (gridMock.expects('validIndices')).atLeast(1).returns(true);
          return emptyStub = sinon.stub(AdjacentCellsCalculator.prototype, 'empty');
        });
        afterEach(function() {
          gridMock.verify();
          return emptyStub.restore();
        });
        it('returns a tuple if the location is empty', function() {
          var result;
          emptyStub.returns(true);
          result = AdjacentCellsCalculator.prototype.validLocation(grid, 1, 2);
          (expect(result.x)).to.equal(1);
          (expect(result.y)).to.equal(2);
          return AdjacentCellsCalculator.prototype.empty.restore();
        });
        return it('returns above if the vertex is taken', function() {
          var result;
          emptyStub.onCall(0).returns(false);
          emptyStub.onCall(1).returns(true);
          result = AdjacentCellsCalculator.prototype.validLocation(grid, 1, 2);
          (expect(result.x)).to.equal(1);
          return (expect(result.y)).to.equal(1);
        });
      };
    })(this));
  });
});
