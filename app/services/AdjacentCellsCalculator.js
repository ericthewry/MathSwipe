// Generated by CoffeeScript 1.9.3
var AdjacentCellsCalculator, Tuple, TupleSet,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Tuple = require('../models/Tuple');

TupleSet = require('../models/TupleSet');

AdjacentCellsCalculator = (function() {
  function AdjacentCellsCalculator(grid1, x1, y1) {
    this.grid = grid1;
    this.x = x1;
    this.y = y1;
    this.isOccupied = bind(this.isOccupied, this);
    this.validLocation = bind(this.validLocation, this);
    this.getToVisit = bind(this.getToVisit, this);
    this.cells = new TupleSet;
  }

  AdjacentCellsCalculator.prototype.getToVisit = function(takenCells) {
    var i, j, k, l, len, len1, ref, ref1, tuple;
    ref = [this.x - 1, this.x, this.x + 1];
    for (k = 0, len = ref.length; k < len; k++) {
      i = ref[k];
      ref1 = [this.y - 1, this.y, this.y + 1];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        j = ref1[l];
        if (!(this.isOccupied(i, j, takenCells) || (i === this.x && j === this.y))) {
          tuple = this.validLocation(this.grid, i, j);
          if (tuple !== null) {
            this.cells.push(tuple);
          }
        }
      }
    }
    return this.cells.list;
  };

  AdjacentCellsCalculator.prototype.validLocation = function(grid, x, y) {
    while (grid.validIndices(x, y)) {
      if (this.grid.isEmpty(x, y)) {
        return new Tuple(x, y);
      }
      y--;
    }
    return null;
  };

  AdjacentCellsCalculator.prototype.isOccupied = function(x, y, takenCells) {
    var cell, k, len;
    for (k = 0, len = takenCells.length; k < len; k++) {
      cell = takenCells[k];
      if (x === cell.x && y === cell.y) {
        return true;
      }
    }
    return false;
  };

  return AdjacentCellsCalculator;

})();

module.exports = AdjacentCellsCalculator;
