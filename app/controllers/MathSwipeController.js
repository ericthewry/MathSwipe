// Generated by CoffeeScript 1.9.3
var $, AdjacentCellsCalculator, Board, BoardSolvedService, Cell, ClickHandler, Colors, DFS, ExpressionGenerator, GeneralTests, GoalContainer, InputSolver, MathSwipeController, RandomizedFitLength, ResetButton, RunningSum, SolutionService;

AdjacentCellsCalculator = require('../services/AdjacentCellsCalculator');

BoardSolvedService = require('../services/BoardSolvedService');

ClickHandler = require('../services/ClickHandler');

DFS = require('../services/DFS');

ExpressionGenerator = require('../services/ExpressionGenerator');

InputSolver = require('../services/InputSolver');

RandomizedFitLength = require('../services/RandomizedFitLength');

ResetButton = require('../services/ResetButton');

RunningSum = require('../services/RunningSum');

SolutionService = require('../services/SolutionService');

Board = require('../views/Board');

GoalContainer = require('../views/GoalContainer');

Cell = require('../views/Cell');

Colors = require('../views/Colors');

GeneralTests = require('../../tests/controllers/GeneralTests');

$ = require('jquery');

MathSwipeController = (function() {
  function MathSwipeController() {
    this.gameScene = this.createGameScene();
    this.symbols = this.getSymbols();
    this.initialize();
    this.bindNewGameButton();
    this.createHowToPlay();
  }

  MathSwipeController.prototype.initialize = function() {
    var answers, expression, gameModel, i, inputLengths, inputSize, inputs, j, k, len, len1, length, value;
    length = 3;
    inputs = [];
    answers = [];
    inputLengths = RandomizedFitLength.generate(length * length);
    for (j = 0, len = inputLengths.length; j < len; j++) {
      inputSize = inputLengths[j];
      value = -1;
      while (value < 1 || value > 300) {
        expression = ExpressionGenerator.generate(inputSize);
        value = InputSolver.compute(expression);
      }
      answers.push(InputSolver.compute(expression));
      inputs.push(expression.split(''));
    }
    for (k = 0, len1 = inputs.length; k < len1; k++) {
      i = inputs[k];
      console.log(i);
    }
    console.log('\n');
    gameModel = this.generateBoard(inputs, length);
    this.goalContainer = new GoalContainer(answers, Colors);
    this.board = new Board(gameModel, this.gameScene, answers, this.symbols, this.goalContainer, this.isMobile().any() != null, Cell, Colors, ClickHandler, SolutionService, BoardSolvedService, RunningSum);
    ResetButton.bindClick(this.board);
    if (this.isMobile().any() == null) {
      return this.cursorToPointer();
    }
  };

  MathSwipeController.prototype.cursorToPointer = function() {
    $('#game').addClass('pointer');
    return $('#game-button-wrapper').addClass('pointer');
  };

  MathSwipeController.prototype.createHowToPlay = function() {
    if (this.isMobile().any() != null) {
      return $('#how-to-play').append('<b>How To Play:</b> Solve the puzzle by clearing the board. Click adjacent tiles to create an equation, and if it equals an answer, the tiles disappear!');
    } else {
      return $('#how-to-play').append('<b>How To Play:</b> Solve the puzzle by clearing the board. Drag your mouse across the tiles to create an equation, and if it equals an answer, the tiles disappear!');
    }
  };

  MathSwipeController.prototype.bindNewGameButton = function() {
    return $('#new-game-button').click((function(_this) {
      return function(e) {
        _this.gameScene.clear();
        _this.goalContainer.clearGoals();
        ResetButton.unbindClick();
        return _this.initialize();
      };
    })(this));
  };

  MathSwipeController.prototype.createGameScene = function() {
    var gameDom, scene, size;
    gameDom = document.getElementById('game');
    size = Math.min(Math.max($(window).width(), 310), 500);
    scene = new Two({
      fullscreen: false,
      autostart: true,
      width: size,
      height: size
    }).appendTo(gameDom);
    return scene;
  };

  MathSwipeController.prototype.createGoalsScene = function() {
    var goalsDom;
    return goalsDom = document.getElementById('goals');
  };

  MathSwipeController.prototype.getSymbols = function() {
    var index, j, len, scene, svg, svgs, symbols;
    scene = new Two();
    svgs = $('#assets svg');
    symbols = [];
    for (index = j = 0, len = svgs.length; j < len; index = ++j) {
      svg = svgs[index];
      symbols.push(scene.interpret(svg));
      symbols[index].visible = false;
    }
    return symbols;
  };

  MathSwipeController.prototype.randExpression = function(length) {
    return ExpressionGenerator.generate(length);
  };

  MathSwipeController.prototype.generateInputs = function(length) {
    var i, inputs, j, ref;
    inputs = [];
    for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      inputs.push(this.randExpression(length).split(''));
    }
    return inputs;
  };

  MathSwipeController.prototype.generateBoard = function(inputs, length) {
    return DFS.setEquationsOnGrid(length, inputs, AdjacentCellsCalculator);
  };

  MathSwipeController.prototype.isMobile = function() {
    return {
      Android: function() {
        return navigator.userAgent.match(/Android/i);
      },
      BlackBerry: function() {
        return navigator.userAgent.match(/BlackBerry/i);
      },
      iOS: function() {
        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
      },
      Opera: function() {
        return navigator.userAgent.match(/Opera Mini/i);
      },
      Windows: function() {
        return navigator.userAgent.match(/IEMobile/i);
      },
      any: function() {
        return this.Android() || this.BlackBerry() || this.iOS() || this.Opera() || this.Windows();
      }
    };
  };

  return MathSwipeController;

})();

module.exports = MathSwipeController;
